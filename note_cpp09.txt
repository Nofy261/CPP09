
ðŸ—„ï¸ 2. Fonctionnement gÃ©nÃ©ral du programme

Le programme doit prendre un seul argument, qui est un fichier texte d'entrÃ©e.

Si aucun fichier nâ€™est passÃ© en argument, tu dois afficher une erreur.

Si le fichier ne peut pas Ãªtre ouvert, tu dois afficher :
â†’ "Error: could not open file."

ðŸ“ 9. Attentes implicites

Lire et parser correctement un CSV.

Lire et parser correctement un fichier ligne par ligne.

Extraire la date et la valeur en validant soigneusement les formats.

Convertir correctement les strings en nombres (flottants).

Utiliser un conteneur ordonnÃ© pour retrouver la date infÃ©rieure la plus proche.

VÃ©rifier toutes les erreurs de format avant de faire un calcul.

Afficher exactement le format du sujet (espaces inclus).

GÃ©rer les cas limites :

plusieurs lignes identiques
valeurs trÃ¨s grandes
dates erronÃ©es
lignes vides
lignes avec espaces supplÃ©mentaires

---------------------------------------------------------------------------------------------

Afficher la valeur de X quantite de bitcoin a X date.

Il y a une base de donnees (format csv) qui represente le prix du btc au fil du temps.

Le programme prend un seul arg d'entree qui est un fichier.txt ---> ./btc file.txt
--> si aucun fichier en arg = affiche message d erreur
--> si fichier n'a pu etre ouvert = "Error: could not open file."

-Dans le file.txt je mets date | value soit Year-Month-Day | value 

Pour chaque ligne du fichier file.txt :
âœ” lire la date et la valeur
âœ” chercher le prix du bitcoin ce jour-lÃ  dans data.csv
âœ” faire le calcul
âœ” afficher le rÃ©sultat dans le terminal

1- Chaque ligne doit avoir le format :

"date | value"
La date doit Ãªtre au format YYYY-MM-DD.
La valeur doit Ãªtre :
un entier positif ou un flottant positif,

compris entre 0 et 1000 inclus.
 : parsing (annee-mois-jour) - bon format
format attendu :
***YYYY-MM-DD | value <-- l'annee en 4 chiffres et le mois et le jour en 2chiffres.
 ex non valide : 2011/01/03 --> valide : 2011-01-03
 ex non valide : 2011-01-03| 45 <-- il faut un espace avant et apres le pipe | 
***value entre 0 et 1000 inclus et peut etre un nombre a virgule (float)
ex ligne invalide : 
2012-01-11 | -1              â†’ Error: not a positive number.
2001-42-42 		     â†’ Error: bad input => 2001-42-42
2012-01-11 | 2147483648      â†’ Error: too large a number.
abc             â†’ Error: bad input
1.2.3           â†’ Error: bad input
Error: could not open file.

Date invalide de Fevrier : (ex. pas 2011-02-30)
Annee correct doit etre composÃ© de 4 chiffres et > 0. (0001 est accepte et considere comme 1)

Le separateur du float est un point et non une virgule.

2- 

Le CSV = base de donnÃ©es fixe.

-Ouvrir le data.csv donnÃ© dans le sujet.
--> si echec d'ouverture afficher erreur et fermer le programme.

-Sinon Lire le csv ligne par ligne 
ligne = date,prix soit 2011-01-03,0.3
--> Il faut parser chaque ligne en separant la date du prix(virgule est separateur ici)
--> convertir le prix 0.3 en float 
--> stocker chaque ligne dans un conteneur jusqu a ce qu'on ait toutes les donnees dans csv.

Câ€™est ce conteneur qui servira Ã  chercher les prix pour le fichier dâ€™entrÃ©e.

3 - Faire le calcul (parsind du fichier d 'entree ici , voir etape 1)

-lire la ligne dans le fichier d'entree : 2012-01-11 | 1
--> "2012-01-11 | 1" considerÃ© comme un string pour le moment ,verifier si c'est au bon format 
sinon message d'erreur et on passe a la ligne suivante.
--> separer en deux : date et value (date = "2012-01-11" et value "1" )
--> verifier la date 2012-01-11 puis la parser et message d'erreur si probleme
--> verifier la value et parser , si erreur on affiche un message .
-Si tout est valide 
--> chercher la date dans le conteneur : 
   --> si date inexisant on prend la date precedente la plus proche 
   --> on fait le calcul result = prix dans le conteneur * value du fichier d'entree.
- Affichage du resultat : YYYY-MM-DD => value = result (2011-01-09 => 1 = 0.32)


line = "2025-01-01 , 46850.23"

std::istringstream ss(line); // creer un flux de lecture pour getline
std::getline(ss, date, ',') : met tout ce qui est avant la virgule dans date donc date = "2025-01-01 "
std::getline(ss, rateStr) : met tout ce qui reste dans rateStr donc rateStr = " 46850.23"

Ã‰tape 1 et 2 : VÃ©rifier, convertir et ajouter dans vector et deque
Ã‰tape 3 : Former des paires
Ã‰tape 4 : Envoyer les mins dans final_vector
Etape 4 bis : trie final_vector
Etape 4 bis : trie final_deque
ETAPE DE JACOBSTAHL
Etape 5 : Insertion des max dans final_vector
Etape 5 : Insertion des max dans final_vector
Etape 6 : gestion du -1;
Etape 7 : Affichage du rÃ©sultat final
Etape 8 : Affichage du temps

1) VÃ©rifier et convertir les arguments
2) Stocker les valeurs dans vector et deque
3) Former des paires (min,max)
4) Extraire mins et maxs
5) Trier mins
6) Construire lâ€™ordre Jacobsthal
7) InsÃ©rer maxs dans mins selon lâ€™ordre Jacobsthal (lower_bound)
8) Si impair â†’ insÃ©rer lâ€™Ã©lÃ©ment restant
9) Affichage rÃ©sultats
10) Affichage temps

./PmergeMe 1 3 5 23 45 1221 5 

parsing :
- que des noombres Positif qui ne dpeasse pas le int max
- ne se repete pas deux fois
- au moins 2 argc et pas vide