
üóÑÔ∏è 2. Fonctionnement g√©n√©ral du programme

Le programme doit prendre un seul argument, qui est un fichier texte d'entr√©e.

Si aucun fichier n‚Äôest pass√© en argument, tu dois afficher une erreur.

Si le fichier ne peut pas √™tre ouvert, tu dois afficher :
‚Üí "Error: could not open file."

üìù 9. Attentes implicites

Lire et parser correctement un CSV.

Lire et parser correctement un fichier ligne par ligne.

Extraire la date et la valeur en validant soigneusement les formats.

Convertir correctement les strings en nombres (flottants).

Utiliser un conteneur ordonn√© pour retrouver la date inf√©rieure la plus proche.

V√©rifier toutes les erreurs de format avant de faire un calcul.

Afficher exactement le format du sujet (espaces inclus).

G√©rer les cas limites :

plusieurs lignes identiques
valeurs tr√®s grandes
dates erron√©es
lignes vides
lignes avec espaces suppl√©mentaires

---------------------------------------------------------------------------------------------

Afficher la valeur de X quantite de bitcoin a X date.

Il y a une base de donnees (format csv) qui represente le prix du btc au fil du temps.

Le programme prend un seul arg d'entree qui est un fichier.txt ---> ./btc file.txt
--> si aucun fichier en arg = affiche message d erreur
--> si fichier n'a pu etre ouvert = "Error: could not open file."

-Dans le file.txt je mets date | value soit Year-Month-Day | value 

Pour chaque ligne du fichier file.txt :
‚úî lire la date et la valeur
‚úî chercher le prix du bitcoin ce jour-l√† dans data.csv
‚úî faire le calcul
‚úî afficher le r√©sultat dans le terminal

1- Chaque ligne doit avoir le format :

"date | value"
La date doit √™tre au format YYYY-MM-DD.
La valeur doit √™tre :
un entier positif ou un flottant positif,

compris entre 0 et 1000 inclus.
 : parsing (annee-mois-jour) - bon format
format attendu :
***YYYY-MM-DD | value <-- l'annee en 4 chiffres et le mois et le jour en 2chiffres.
 ex non valide : 2011/01/03 --> valide : 2011-01-03
 ex non valide : 2011-01-03| 45 <-- il faut un espace avant et apres le pipe | 
***value entre 0 et 1000 inclus et peut etre un nombre a virgule (float)
ex ligne invalide : 
2012-01-11 | -1              ‚Üí Error: not a positive number.
2001-42-42 		     ‚Üí Error: bad input => 2001-42-42
2012-01-11 | 2147483648      ‚Üí Error: too large a number.
abc             ‚Üí Error: bad input
1.2.3           ‚Üí Error: bad input
Error: could not open file.

Date invalide de Fevrier : (ex. pas 2011-02-30)
Annee correct doit etre compos√© de 4 chiffres et > 0. (0001 est accepte et considere comme 1)

Le separateur du float est un point et non une virgule.

2- 

Le CSV = base de donn√©es fixe.

-Ouvrir le data.csv donn√© dans le sujet.
--> si echec d'ouverture afficher erreur et fermer le programme.

-Sinon Lire le csv ligne par ligne 
ligne = date,prix soit 2011-01-03,0.3
--> Il faut parser chaque ligne en separant la date du prix(virgule est separateur ici)
--> convertir le prix 0.3 en float 
--> stocker chaque ligne dans un conteneur jusqu a ce qu'on ait toutes les donnees dans csv.

C‚Äôest ce conteneur qui servira √† chercher les prix pour le fichier d‚Äôentr√©e.

3 - Faire le calcul (parsind du fichier d 'entree ici , voir etape 1)

-lire la ligne dans le fichier d'entree : 2012-01-11 | 1
--> "2012-01-11 | 1" consider√© comme un string pour le moment ,verifier si c'est au bon format 
sinon message d'erreur et on passe a la ligne suivante.
--> separer en deux : date et value (date = "2012-01-11" et value "1" )
--> verifier la date 2012-01-11 puis la parser et message d'erreur si probleme
--> verifier la value et parser , si erreur on affiche un message .
-Si tout est valide 
--> chercher la date dans le conteneur : 
   --> si date inexisant on prend la date precedente la plus proche 
   --> on fait le calcul result = prix dans le conteneur * value du fichier d'entree.
- Affichage du resultat : YYYY-MM-DD => value = result (2011-01-09 => 1 = 0.32)


line = "2025-01-01 , 46850.23"

std::istringstream ss(line); // creer un flux de lecture pour getline
std::getline(ss, date, ',') : met tout ce qui est avant la virgule dans date donc date = "2025-01-01 "
std::getline(ss, rateStr) : met tout ce qui reste dans rateStr donc rateStr = " 46850.23"

√âtape 1 et 2 : V√©rifier, convertir et ajouter dans vector et deque
√âtape 3 : Former des paires
√âtape 4 : Envoyer les mins dans final_vector
Etape 4 bis : trie final_vector
Etape 4 bis : trie final_deque
ETAPE DE JACOBSTAHL
Etape 5 : Insertion des max dans final_vector
Etape 5 : Insertion des max dans final_vector
Etape 6 : gestion du -1;
Etape 7 : Affichage du r√©sultat final
Etape 8 : Affichage du temps

1) V√©rifier et convertir les arguments
2) Stocker les valeurs dans vector et deque
3) Former des paires (min,max)
4) Extraire mins et maxs
5) Trier mins + penser a commencer le chrono
6) Construire l‚Äôordre Jacobsthal
7) Ins√©rer maxs dans mins selon l‚Äôordre Jacobsthal (lower_bound)
8) Si impair ‚Üí ins√©rer l‚Äô√©l√©ment restant
9) Affichage r√©sultats
10) Affichage temps

./PmergeMe 1 3 5 23 45 1221 5 

parsing :
- que des noombres Positif qui ne dpeasse pas le int max
- ne se repete pas deux fois
- au moins 2 argc et pas vide

Rappel rapide de l‚Äôid√©e :
La suite de Jacobsthal sert √† d√©cider quel √©l√©ment du vecteur maxVec ins√©rer en premier dans le vecteur tri√© minVec.

Les indices de cette suite te donnent l‚Äôordre d‚Äôinsertion.

Ensuite, pour chaque √©l√©ment √† ins√©rer, tu utilises std::lower_bound pour trouver la bonne position dans le vecteur tri√© 
et l‚Äôins√©rer √† cet endroit.

√âtapes concr√®tes pour le faire :
Construire la suite de Jacobsthal jusqu‚Äô√† la taille de maxVec.
La suite commence par : 0, 1, 3, 5, 11, 21, ‚Ä¶
Formule r√©cursive : J(n) = J(n-1) + 2*J(n-2)
Parcourir maxVec dans l‚Äôordre donn√© par la suite de Jacobsthal.
Pour chaque √©l√©ment de maxVec :
Trouver sa position dans le minVec tri√© avec std::lower_bound.
L‚Äôins√©rer √† cette position.
